-- Two soliders wait for torch and cross the bridge, anyone of them can come back
MODULE runner(solider1, solider2, total_time, torch)
VAR 
    location: {waiting_start, waiting_end, crossing, goingback};
    
ASSIGN
    init(location) := waiting;
    next(location) := case
        location = waiting_start: {waiting_start, crossing};
        location = waiting_end: {waiting_end, goingback};
        -- if two soilder and torch are both available then cross the bridge
        location = crossing & solider1 = free & solider2 = free & torch = free: crossing;

        fuck
        fuck
        fuck

MODULE main
VAR
    total_time : 0 .. 1000;
    torch: {free, taken};
    soliders_time : array 0 .. 3 of {5, 10, 20, 25};
    soliders_status : array 0 .. 3 of {waiting_start, waiting_end};

    s1 : process runner(soliders_status[0], soliders_status[1], total_time, torch);
    s2 : process runner(soliders_status[0], soliders_status[2], total_time, torch);
    s3 : process runner(soliders_status[0], soliders_status[3], total_time, torch);

    s4 : process runner(soliders_status[1], soliders_status[0], total_time, torch);
    s4 : process runner(soliders_status[1], soliders_status[2], total_time, torch);
    s5 : process runner(soliders_status[1], soliders_status[3], total_time, torch);

    s6 : process runner(soliders_status[2], soliders_status[0], total_time, torch);
    s6 : process runner(soliders_status[2], soliders_status[1], total_time, torch);
    s6 : process runner(soliders_status[2], soliders_status[3], total_time, torch);

    s6 : process runner(soliders_status[3], soliders_status[0], total_time, torch);
    s6 : process runner(soliders_status[3], soliders_status[1], total_time, torch);
    s6 : process runner(soliders_status[3], soliders_status[2], total_time, torch);

ASSIGN
    init(torch) := free;
    init(soliders_status[0]) := waiting_start;
    init(soliders_status[1]) := waiting_start;
    init(soliders_status[2]) := waiting_start;
    init(soliders_status[3]) := waiting_start;